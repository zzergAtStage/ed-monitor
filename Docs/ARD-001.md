ADR: ED-Monitor Route Optimizer v1 (Single Construction Site, Greedy Client-Side Planner)

ADR ID: ADR-ROUTE-001
Status: Accepted (v1)
Date: 2025-11-16
Context/Owner: ED-Monitor, Route Optimization feature for Construction Sites

1. Context

The ED-Monitor application currently tracks Elite Dangerous game events, including Construction Sites, Markets (stations) and Commodities, using an ed-monitor-server backend and a Swing client.

We want to help the commander plan delivery runs to supply a single selected Construction Site with required materials. The aim is to minimize the number of travels (runs and legs), using:

Inputs only from existing ed-monitor-server API:

ConstructionSiteDto with material requirements (required, delivered, remaining).

Market / commodity data (markets, available stock, prices, etc.).

Offline accumulated market data (no real-time pricing; “whatever the server has from logs”).

A uniform cost model for v1:

Each leg (Station → Station, Station → Site, Site → Station) has equal cost.

A ship with cargo capacity C (tons).

Formally this resembles a mix of Traveling Purchaser Problem and Capacitated Vehicle Routing, which is NP-hard. For a helper tool, we don’t need exact optimality; we need:

A predictable, explainable heuristic.

“Human-like” routes (what a reasonable commander would plan).

Good performance on tens of markets and 10–20 materials.

We also want this to be friendly for automation (OpenAI Codex agents) by exposing a clean service boundary and DTO-based contracts, with work split into incremental tasks.

2. Decision

Scope for v1

Optimize one selected Construction Site at a time.

Objective:

Primary: minimize number of runs.

Secondary (within a run): use capacity efficiently and prefer markets that cover more required materials.

Cost model: all legs have equal cost (no distances/SC-time yet).

Use offline accumulated market data from ed-monitor-server.

Algorithm strategy

Implement a greedy heuristic on the client side:

Limit maxMarketsPerRun (e.g. default = 2).

Prefer markets that:

Sell scarce materials (few seller markets).

Cover many required materials (high coverage).

Fill cargo per run greedily until capacity is full or market stock is exhausted.

Stop when:

No remaining material demand, or

No stock in any candidate market.

Implementation overview (v1)

RouteOptimizationService → GreedyRouteOptimizationService  
RouteOptimizerDataProvider → DefaultRouteOptimizerDataProvider (OkHttp).  
UI integration via RouteOptimizerModel, RouteOptimizerController, RouteOptimizerPanel/Dialog.

Location of v1 implementation

v1 optimization logic lives in the Swing client (ed-monitor-swing).

The optimizer depends on:

Existing server DTOs (ConstructionSiteDto, MarketDto, etc.).

A new data provider interface to fetch server data.

We introduce a RouteOptimizationService interface on the client as a domain boundary.
This allows us to later move the implementation to ed-monitor-server with minimal changes to UI.

Contracts / DTOs

Define client-side DTOs under ed-monitor-swing, e.g. in com.zergatstage.monitor.routes.dto:

RouteOptimizationRequest

Long constructionSiteId

double cargoCapacityTons

int maxMarketsPerRun (default 2)

RoutePlanDto

Long constructionSiteId

List<DeliveryRunDto> runs

double coverageFraction (0–1 of remaining demand covered)

DeliveryRunDto

int runIndex

List<RunLegDto> legs

double totalTonnage

Map<String, Double> materialsSummaryTons

RunLegDto

Long marketId

String marketName

List<PurchaseDto> purchases

PurchaseDto

String materialName

double amountTons

These are UI-agnostic POJOs with JavaDoc. No Swing dependencies.

Service boundary

Client-side service interface:

/**
 * Builds a near-optimal route plan for supplying a single construction site
 * with required materials from available markets.
 *
 * <p>Assumptions (v1):
 * <ul>
 *   <li>All travel legs have equal cost.</li>
 *   <li>Only one construction site is optimized at a time.</li>
 *   <li>Market data is based on offline accumulated logs.</li>
 * </ul>
 * </p>
 */
public interface RouteOptimizationService {

    /**
     * Creates a route plan for the given construction site and parameters.
     *
     * @param request optimization parameters, including construction site id,
     *                cargo capacity and the maximum number of markets per run
     * @return a route plan with zero or more delivery runs; never {@code null}
     */
    RoutePlanDto buildRoutePlan(RouteOptimizationRequest request);
}


A greedy implementation GreedyRouteOptimizationService will implement this interface and encapsulate all heuristic logic.

Data access facade

We introduce a dedicated data provider:

/**
 * Abstraction for retrieving construction site and market data for route optimization.
 *
 * <p>Hides HTTP / REST details from the optimization algorithm and exposes
 * an in-memory view of requirements and candidate markets.</p>
 */
public interface RouteOptimizerDataProvider {

    /**
     * Loads the construction site with material requirements.
     *
     * @param constructionSiteId id of the construction site
     * @return DTO with remaining requirements; never {@code null}
     */
    ConstructionSiteDto loadConstructionSite(Long constructionSiteId);

    /**
     * Loads candidate markets that sell at least one required material for the
     * specified construction site.
     *
     * @param constructionSiteId id of the construction site
     * @return list of markets with their commodities and stock; may be empty
     */
    List<MarketDto> loadCandidateMarkets(Long constructionSiteId);
}


v1: a default implementation in ed-monitor-swing uses existing REST clients.

If no dedicated “candidate markets” endpoint exists, it filters markets client-side and leaves a TODO for server-side optimization.

Greedy algorithm outline (v1)

Pre-processing:

Load ConstructionSiteDto → build remaining[m] for each material.

Load candidate markets and their MarketCommodityDtos.

Compute:

sellerCount(m) per material.

Scarcity weights (few sellers → high weight).

Loop while there is any remaining[m] > 0 and markets with stock:

Select primary market:

Score each market s by:

Total achievable tonnage for still-needed materials:
Σ_m min(remaining[m], q_(s,m))

Scarcity contribution: Σ_m scarcityWeight(m) for materials it sells.

Pick the market with the highest combined score.

Fill cargo at primary market:

Capacity cap = C.

Sort its materials by:

Scarcity (descending), then

Remaining demand (descending).

For each material: load min(remaining[m], q_(s,m), cap) until cap == 0 or stock exhausted.

Optionally add secondary markets:

While cap > 0 and visitedMarkets < maxMarketsPerRun:

Choose next market by marginal coverage given remaining cap and remaining[m].

Fill greedily as above.

Finalize run:

Build DeliveryRunDto with ordered RunLegDtos.

Append to RoutePlanDto.runs.

coverageFraction = (total delivered tonnage toward remaining demand) / (initial remaining demand).

UI / MVC architecture

Treat Route Optimizer as a separate MVC triad in ed-monitor-swing:

Model: RouteOptimizerModel

Holds current ConstructionSiteDto or id.

Holds current RouteOptimizationRequest.

Holds current RoutePlanDto.

Not tied to Swing widgets; may use PropertyChangeSupport or the app’s usual pattern.

Controller: RouteOptimizerController

Talks to RouteOptimizerDataProvider and RouteOptimizationService.

Fetches data, builds requests, triggers optimization, updates model.

Handles errors (network, empty data).

View: RouteOptimizerDialog / RouteOptimizerPanel

Presents:

Site summary (delivered/remaining).

Capacity and maxMarketsPerRun fields.

Runs table + run details.

Coverage indicator.

Hooks into the model to refresh on changes.

Exposed from Construction Sites tab via “Plan Route…” action.

Server-side future

v1: no server-side optimization; only client side.

However, we define a server contract now:

DTOs analogous to the client ones.

REST endpoint (skeleton):

POST /api/v1/construction-sites/{id}/route-plan
Request: RouteOptimizationRequestDto
Response: RoutePlanDto

Current implementation may simply return HTTP 501 (Not Implemented) with a clear TODO.

This lets us later move the algorithm to ed-monitor-server (or add a more advanced one) without changing the Swing client’s expectations.

Multi-site extension (later)

DTOs are designed to be extendable:

RouteOptimizationRequest can later accept a List<Long> constructionSiteIds.

Algorithm can later be generalized to:

Combine requirements of 2–5 sites.

Possibly support runs that deliver to more than one site.

This complexity is explicitly out of scope for v1.

3. Rationale (my view)

Greedy heuristic vs exact optimization
In my opinion, for a helper tool integrated into a game companion, an exact solver (ILP, metaheuristics) would be overkill in v1: more complex to implement, harder to debug, and harder to explain. A greedy strategy based on scarcity + coverage is:

Easy to reason about.

Close to what a human would do.

Fast for tens of markets and materials.

Client-side v1
Running the algorithm in the Swing client:

Avoids server refactoring and DevOps overhead for now.

Keeps iteration fast.

Matches the fact that the server already exposes the necessary data read-only.

Service boundary and DTOs now
Introducing RouteOptimizationService and route DTOs from the start:

Gives Codex agents and humans a stable contract to work against.

Makes tasks independent and composable.

Minimizes future changes when we move logic to the server.

UI separated from logic
Keeping optimization logic in services and models, not in Swing components, preserves code quality and matches your clean-code preferences.

4. Consequences

Positive:

Clear, explicit boundary (RouteOptimizationService, DTOs, data provider).

Algorithm is readable, testable, and explainable.

UI and algorithm evolve independently.

Easy to automate with Codex agents: each conceptual piece maps to a concrete task.

Negative / Risks:

For very large data sets, client-side filtering of markets might become heavy (we accept this for v1).

Uniform cost ignores distance and time; routes might not be “physically optimal” in-game (documented limitation).

Greedy heuristic may miss better global plans (known and accepted trade-off).

Mitigations:

Write good unit tests for the greedy service to pin down behavior.

Document limitations clearly in JavaDoc and in the UI (tooltip / info section).

Prepare server contract to allow consistent migration to server-side optimization later.

5. Alternatives Considered

Exact optimization with ILP / meta-heuristics on the server

Pros: better global optimum, flexible cost models.

Cons: high implementation complexity, requires more ops work and tuning, harder to explain.

Decision: postponed for future versions.

Ad-hoc logic embedded in Swing UI

Pros: quickest initial hack.

Cons: tight coupling between UI and domain logic, hard to test and evolve, unfriendly to automation.

Decision: rejected.

Server-side implementation from day one

Pros: central logic, reusable by other clients.

Cons: requires server changes and deployment before we validate the heuristic and UX.

Decision: we chose client-side first with a forward-compatible server contract.

6. Implementation via Tasks

The ADR is implemented through a set of incremental tasks in TASKS.md, designed for OpenAI Codex / automation. They cover:

Defining DTOs and service interfaces (T-100, T-110).

Implementing the data provider (T-120).

Implementing the greedy service and its tests (T-130, T-140).

Adding model, controller and UI (T-150, T-160).

Preparing the server-side contract (T-170).

These tasks are intentionally narrow so that an agent can execute them step-by-step, with minimal context and minimal token usage.
